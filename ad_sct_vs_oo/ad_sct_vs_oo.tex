%% Based on a TeXnicCenter-Template by Gyorgy SZEIDL.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%------------------------------------------------------------
%
\documentclass{amsart}
%
%----------------------------------------------------------
% This is a sample document for the AMS LaTeX Article Class
% Class options
%        -- Point size:  8pt, 9pt, 10pt (default), 11pt, 12pt
%        -- Paper size:  letterpaper(default), a4paper
%        -- Orientation: portrait(default), landscape
%        -- Print size:  oneside, twoside(default)
%        -- Quality:     final(default), draft
%        -- Title page:  notitlepage, titlepage(default)
%        -- Start chapter on left:
%                        openright(default), openany
%        -- Columns:     onecolumn(default), twocolumn
%        -- Omit extra math features:
%                        nomath
%        -- AMSfonts:    noamsfonts
%        -- PSAMSFonts  (fewer AMSfonts sizes):
%                        psamsfonts
%        -- Equation numbering:
%                        leqno(default), reqno (equation numbers are on the right side)
%        -- Equation centering:
%                        centertags(default), tbtags
%        -- Displayed equations (centered is the default):
%                        fleqn (equations start at the same distance from the right side)
%        -- Electronic journal:
%                        e-only
%------------------------------------------------------------
% For instance the command
%          \documentclass[a4paper,12pt,reqno]{amsart}
% ensures that the paper size is a4, fonts are typeset at the size 12p
% and the equation numbers are on the right side
%
\usepackage{amsmath}%
\usepackage{amsfonts}%
\usepackage{amssymb}%
\usepackage{graphicx}
\usepackage[miktex]{gnuplottex}
\ShellEscapetrue
\usepackage{epstopdf}
\usepackage{longtable}
\usepackage{minted}
\definecolor{mintedBg}{rgb}{0.98,0.98,0.70}
%------------------------------------------------------------
% Theorem like environments
%
\newtheorem{theorem}{Theorem}
\theoremstyle{plain}
\newtheorem{acknowledgement}{Acknowledgement}
\newtheorem{algorithm}{Algorithm}
\newtheorem{axiom}{Axiom}
\newtheorem{case}{Case}
\newtheorem{claim}{Claim}
\newtheorem{conclusion}{Conclusion}
\newtheorem{condition}{Condition}
\newtheorem{conjecture}{Conjecture}
\newtheorem{corollary}{Corollary}
\newtheorem{criterion}{Criterion}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{exercise}{Exercise}
\newtheorem{lemma}{Lemma}
\newtheorem{notation}{Notation}
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}
\newtheorem{remark}{Remark}
\newtheorem{solution}{Solution}
\newtheorem{summary}{Summary}
\numberwithin{equation}{section}
%--------------------------------------------------------
\DeclareMathOperator{\sign}{sign}
%--------------------------------------------------------
\begin{document}
\title[AD]{Automatic Differentiation Case Study}
\author{P. Caspers}
\email[P. Caspers]{pcaspers1973@googlemail.com}
\date{July 12, 2015}
\dedicatory{First Version July 14, 2015 - This Version July 14, 2015}
\begin{abstract}
This is a case study in computing adjoint derivatives with (a) operator overloading using CppAD and ADOL-C and (b) source code transformation using OpenAD/F.
\end{abstract}

\maketitle

\tableofcontents

\section{Sample Problem}

We consider a local volatility asset process 

\begin{eqnarray}
dS &=& \sigma(S,t) S dW \\
d\log(S) &=& -\frac{1}{2}\sigma(S,t)^2 dt + \sigma(S,t) dW
\end{eqnarray}

and the valuation of an american call option with maturity $T$ and strike $K$ in this model. We aim to compute the price using a simple Euler finite difference scheme. The call price $c = c(t,X), X:=\log(S)$ obeys

\begin{equation}
dc = \left(c_t + \frac{1}{2} \sigma(S,t)^2 (c_{XX}-c_{X}) \right) dt + c_X \sigma(S,t) dW 
\end{equation}

from where we get the backward PDE

\begin{equation}
c_t + \frac{1}{2}\sigma(S,t)^2(c_{XX}-c_X) = 0
\end{equation}

with initial condition $c(T,X(T)) = \max\{ e^{X(T)}  - K, 0 \}$.





\begin{thebibliography}{2}

\bibitem{ql}QuantLib A free/open-source library for quantitative finance, http://www.quantlib.org

\end{thebibliography}



\section{Test enviroment}

Intel(R) Core(TM) i7-2760QM CPU @ 2.40GHz, single threaded, Ubuntu 14.04, gcc 4.9.2, ADOL-C-2.5.2, CppAD git repository 02a00a, optimization -O3

\section{Source Code}


\subsection{CppAD, ADOL-C C++ code}

File \verb+testcpp.cpp+

\begin{minted}{c++}
// define to enable AD
//#define CPPAD

// define to enable ADOL-C
#define ADOLC

// define for plain computation
//#define PLAIN

#include <iostream>
#include <vector>
#include <cmath>

#ifdef CPPAD
#include <cppad/cppad.hpp>
using CppAD::AD;
typedef AD<double> dbl;
#endif

#ifdef ADOLC
#include <adolc/adolc.h>
typedef adouble dbl;
#endif

#ifdef PLAIN
typedef double dbl;
#endif

// problem data
const dbl S0 = std::log(100.0);
const double T = 10.0;
const dbl K = std::log(120.0);
const unsigned int n = 500; // sigma grid

// PDE parameters
const dbl Smin = 1.07555172964;
const dbl Smax = 8.13478864234;
const unsigned int sizeS = 2 * 50 + 1;
const unsigned int sizeT = 500 * 10;

// solution grid
dbl loc[sizeS + 1], c[2][sizeS], exerciseValue[sizeS];

int main() {

#ifdef PLAIN
    std::vector<dbl> implVol(n, 0.20);
#endif

#ifdef CPPAD
    std::vector<dbl> implVol(n, 0.20);
    CppAD::Independent(implVol);
#endif

#ifdef ADOLC
    int tag = 1, keep = 1;
    adouble *implVol;
    implVol = new adouble[n];
    trace_on(tag, keep);
    for (unsigned int i = 0; i < n; ++i)
        implVol[i] <<= 0.20;
#endif

    unsigned int swap = 0;

    // initial values
    const dbl h = (Smax - Smin) / static_cast<dbl>(sizeS - 1);
    const dbl hq = h * h;
    for (unsigned int j = 0; j < sizeS; ++j) {
        loc[j] = Smin + h * static_cast<double>(j);
        c[swap][j] = exerciseValue[j] =
            std::max<dbl>(exp(loc[j]) - exp(K), 0.0);
    }

    // PDE solver
    const double dt = T / static_cast<double>(sizeT);
    for (unsigned int i = 0; i < sizeT; ++i) {
        // rollback
        for (unsigned int j = 0; j < sizeS; ++j) {
            const dbl v = implVol[static_cast<int>(static_cast<double>(i) *
                                                   static_cast<double>(n) /
                                                   static_cast<double>(sizeT))];
            dbl d1, d2;
            if (j == 0 || j == sizeS - 1) {
                d2 = 0.0;
            } else {
                d2 = (c[swap][j + 1] - 2.0 * c[swap][j] + c[swap][j - 1]) / hq;
            }
            if (j == 0) {
                d1 = (c[swap][j + 1] - c[swap][j]) / h;
            } else {
                if (j == sizeS - 1) {
                    d1 = (c[swap][j] - c[swap][j - 1]) / h;
                } else {
                    d1 = (c[swap][j + 1] - c[swap][j - 1]) / (2.0 * h);
                }
            }
            // Euler
            c[1 - swap][j] = c[swap][j] + 0.5 * dt * v * v * (d2 - d1);
        }
        // update prices
        for (unsigned int j = 0; j < sizeS; ++j) {
            c[1 - swap][j] = std::max(c[1 - swap][j], exerciseValue[j]);
        }
        swap = 1 - swap;
    }

    // solution output
    std::clog.precision(12);
    std::clog << "c(0,0) = " << c[swap][(sizeS - 1) / 2] << std::endl;

#ifdef CPPAD
    std::vector<dbl> y(1);
    y[0] = c[swap][(sizeS - 1) / 2];
    CppAD::ADFun<double> f(implVol, y);
    std::vector<double> w(1, 1.0);
    std::vector<double> vega(n - 1);
    vega = f.Reverse(1, w);
    double sum = 0.0;
    for (unsigned int i = 0; i < n - 1; ++i) {
        sum += vega[i];
    }
    // std::vector<double> x0(n - 1, 1.0);
    // sum = f.Forward(1,x0);
    std::clog << "vega =" << sum << std::endl;
#endif

#ifdef ADOLC
    double yout;
    c[swap][(sizeS - 1) / 2] >>= yout;
    trace_off();
    double u[1];
    u[0] = 1.0;
    double *vega = new double[n];
    reverse(tag, 1, n, 0, u, vega);
    std::clog << "computing vega...." << std::endl;
    double sum = 0.0;
    for (unsigned int i = 0; i < n; ++i) {
        sum += vega[i];
    }
    std::clog << "vega =" << sum << std::endl;
    delete[] implVol;
    delete[] vega;
#endif

} // main
\end{minted}

\subsection{OpenAD/F Fortran code, main part}

File \verb+testf90.f90+:

\begin{minted}{fortran}
subroutine toy_pde(impliedVol,price)
implicit none

integer, parameter:: n = 500

double precision:: impliedVol(0:n-1), price

double precision, parameter:: s0=4.605170185988092d0,
                              k=4.787491742782046, t=10.0d0
double precision, parameter:: smin=1.07555172964d0, 
                              smax=8.13478864234d0
integer, parameter:: sizes = 101, sizet = 5000

double precision:: loc(0:sizes), c(0:1,0:sizes-1), 
                   exerciseValue(0:sizes-1)
double precision:: h, hq, dt, d1, d2, v
integer:: swap, i, j, ind

!$openad INDEPENDENT(impliedVol)

swap = 0

! initial values
h = (smax-smin)/dble(sizes-1)
hq = h*h
do j=0,sizeS-1,1
    loc(j) = smin + h*dble(j)
    c(swap,j) = max(dexp(loc(j))-dexp(K),0.0d0)
    exerciseValue(j) = c(swap,j)
end do

! PDE solver
dt = t / dble(sizeT)
do i=0,sizeT-1,1
    do j=0,sizeS-1,1
       ind = int(dble(n)*dble(i)/dble(sizeT))
       v = impliedVol(ind)
       if(j==0.or.j==sizeS-1) then
          d2=0
          d1=0 ! we do not really want this ...
       else
          d2=(c(swap,j+1)-2.0d0*c(swap,j)+c(swap,j-1))/hq
          d1 = (c(swap,j+1)-c(swap,j-1))/(2.0d0*h)
       endif
       ! ... but the following code does not build with OpenAD:
       ! if(j==0) d1 = (c(swap,j+1)-c(swap,j))/h
       ! if(j==sizeS-1) d1 = (c(swap,j)-c(swap,j-1))/h
       ! if(j>0.and.j<sizeS-1) d1 = (c(swap,j+1)-c(swap,j-1))
       !                                           /(2.0d0*h)
       c(1-swap,j)=c(swap,j) + 0.5 * dt * v*v * (d2-d1)
     end do
     do j=0,sizeS-1,1
        c(1-swap,j)=max(c(1-swap,j),exerciseValue(j))
     end do
     swap = 1 -swap
end do
  
! return solution
price = c(swap,(sizeS-1)/2)

!$openad DEPENDENT(price)

end subroutine toy_pde
\end{minted}

\subsection{OpenAD/F Fortran code, driver plain computation}

File \verb+driverf90_plain.f90+:

\begin{minted}{fortran}
program driver
implicit none
external toy_pde

integer,parameter::n=500
integer::i
double precision::impliedVol(0:n-1),price

do i=0,n-1,1
   impliedVol(i) = 0.20d0
end do

call toy_pde(impliedVol, price)

write(*,*) 'c = ', price

end program driver
\end{minted}

\subsection{OpenAD/F Fortran code, driver forward mode}

File \verb+driverf90_forward.f90+:

\begin{minted}{fortran}
program driver
use OAD_active
implicit none
external toy_pde

integer, parameter:: n = 500

type(active)::impliedVol(0:n-1),price

double precision::vega
integer::i

do i=0,n-1,1
   impliedVol(i)%v=0.20d0
   impliedVol(i)%d=1.0
end do

call toy_pde(impliedVol, price)

vega = price%d

write(*,*) 'c = ', price%v, ' dprice/dvol = ', vega

end program driver
\end{minted}

\subsection{OpenAD/F Fortran code, driver reverse mode}

File \verb+driverf90.f90+:

\begin{minted}{fortran}
program driver
use OAD_active
use OAD_rev
implicit none
external toy_pde

integer, parameter:: n = 500

type(active)::impliedVol(0:n-1),price

double precision::vega
integer::i

do i=0,n-1,1
   impliedVol(i)%v=0.20d0
end do

price%d=1.0d0
our_rev_mode%tape=.true.

call toy_pde(impliedVol, price)

do i=0,n-1,1
   vega = vega + impliedVol(i)%d
end do

write(*,*) 'c = ', price%v, ' dprice/dvol = ', vega

end program driver
\end{minted}

\subsection{OpenAD/F makefile plain computation}

File \verb+Makefile_plain+:

\begin{minted}{makefile}
ifndef F90C
F90C=gfortran
endif
driverf90_plain: driverf90_plain.o testf90.o
	${F90C} -O3 -o $@ $^
testf90.f90, driverf90_plain.f90:
%.o : %.f90
	${F90C} -g -O3 -o $@ -c $<
clean:
	rm -f testf90.o driverf90_plain.o
.PHONY: clean toolChain
\end{minted}

\subsection{OpenAD/F makefile forward mode}

File \verb+Makefile_forward+:

\begin{minted}{makefile}
ifndef F90C
F90C=gfortran
endif
RTSUPP=w2f__types OAD_active
driverf90_forward: $(addsuffix .o, $(RTSUPP)) driverf90_forward.o
                                              testf90.pre.xb.x2w.w2f.post.o
	${F90C} -O3 -o $@ $^
testf90.pre.xb.x2w.w2f.post.f90 $(addsuffix .f90, $(RTSUPP)) : toolChain
toolChain : testf90.f90
	openad -c -m f $<
%.o : %.f90
	${F90C} -g -O3 -o $@ -c $<
clean:
	rm -f ad_template* OAD_* w2f__* iaddr*
	rm -f testf90.pre* *.B *.xaif *.o *.mod driver driverE *~
.PHONY: clean toolChain
\end{minted}

\subsection{OpenAD/F makefile reverse mode}

File \verb+Makefile+:

\begin{minted}{makefile}
ifndef F90C
F90C=gfortran
endif
ifndef CC
CC=gcc
endif
RTSUPP=w2f__types OAD_active OAD_cp OAD_tape OAD_rev
driverf90: $(addsuffix .o, $(RTSUPP)) driverf90.o testf90.pre.xb.x2w.w2f.post.o
	${F90C} -O3 -o $@ $^
testf90.pre.xb.x2w.w2f.post.f90 $(addsuffix .f90, $(RTSUPP)) iaddr.c : toolChain
toolChain : testf90.f90
	openad -c -m rj $<
%.o : %.f90
	${F90C} -g -O3 -o $@ -c $<
%.o : %.c
	${CC} -g -O3 -o $@ -c $<
clean:
	rm -f ad_template* OAD_* w2f__* iaddr*
	rm -f testf90.pre* *.B *.xaif *.o *.mod driver driverE *~
.PHONY: clean toolChain
\end{minted}


\end{document}

