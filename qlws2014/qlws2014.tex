\documentclass{beamer}

\usetheme{CambridgeUS}
\usefonttheme{professionalfonts}

\usepackage{graphicx}
\usepackage[miktex]{gnuplottex}
\ShellEscapetrue
\usepackage{epstopdf}
\usepackage{minted}

\usemintedstyle{manni}
\definecolor{mintedBg}{rgb}{0.98,0.98,0.70}

\begin{document}
\title{QuantLib Erlk\"onige}  
\author{Peter Caspers}
\institute{IKB}
\date{December 4th 2014} 

\frame{\titlepage} 

\begin{frame}[fragile]
\frametitle{Erlk\"onig}
\resizebox{\textwidth}{!}{
\begin{minipage}{2.5\textwidth}
\begin{figure}
	\centering
		\includegraphics{../../../Pictures/erlkoenige/Erlkoenig-VW-Golf-VII-Variant-729x486-657b2da7653d9840.jpg}
\end{figure}
\end{minipage}}
\end{frame}

\frame{\frametitle{Table of contents}\tiny\tableofcontents[hideallsubsections]} 

\section{No Arbitrage SABR}

\frame{\frametitle{No Arbitrage SABR - the model}
Paul Doust, No-arbitrage SABR, Journal of Computational Finance, Volume 15 / Number 3, Spring 2012. Main Features:
\begin{enumerate}
\item approximates the density (with a positive function), thereby producing an arbitrage free smile over strike range $[0,\infty)$
\item assumes arbsorbing barrier at $F=0$ and reproduces precomputed arbsorption probabilities generated by a MC simulation (published by Paul Doust as well)
\item call prices are computed by numerical integration, implied volatilities are computed by inverting the Black formula
\end{enumerate}
}

% just to generate figure
% \begin{frame}[fragile]
% \begin{figure}
% 	 \begin{gnuplot}
% 	 	set terminal epslatex color
% 	 	set xrange [0:0.10]
% 	 	set yrange [-50:50]
% 	 	set xlabel "strike"
% 	 	set ylabel "density"
%         set grid
% 	 	plot 'out.txt' u 1:5 w l title 'Hagan (2002)', '' u 1:9 w l title 'Doust' 
% 	 \end{gnuplot}
% \end{figure}
% \end{frame}


\frame{\frametitle{No Arbitrage SABR Example}
\resizebox{\textwidth}{!}{
\begin{minipage}{1.5\textwidth}
\begin{figure}
\input{qlws2014-gnuplottex-fig1.tex}
\caption{SABR smile $\alpha=0.01$, $\beta=0.40$, $\nu=0.20$, $\rho=-0.30$, $\tau=30.0$, $f=0.03$}
\end{figure}
\end{minipage}}
}

\begin{frame}[fragile]
\frametitle{No Arbitrage SABR classes}

\verb+ql/experimental/volatility/+

\begin{table}
\begin{tabular}{l|l}
\verb+NoArbSabrModel+ & core computation formulas \\
\verb+NoArbSabrInterpolation+ & interpolation class \\
\verb+NoArbSabrSmileSection+ & smile section by parameters \\
\verb+NoArbSabrInterpolatedSmileSection+ & interpolating smile section \\
\verb+SwaptionVolcube1a+ & volatility cube 
\end{tabular}
\end{table}
\end{frame}

\begin{frame}[fragile]
\frametitle{Design changes}
Make the SABR interpolation and volatility cube classes generic, so that both models (and possibly more like SVI, ZABR) are accepted. The old \verb+SwaptionVolCube1+ class e.g. is now retrieved by 
\begin{minted}[bgcolor=mintedBg]{c++}
struct SwaptionVolCubeSabrModel {
        typedef SABRInterpolation Interpolation;
        typedef SabrSmileSection SmileSection;
};

typedef SwaptionVolCube1x<SwaptionVolCubeSabrModel> 
                                      SwaptionVolCube1;

\end{minted}
and likewise for the new ``1a''-variant of the cube using the noarb-SABR formula.
\end{frame}

\frame{\frametitle{NoArbSABR - Limitations}

\begin{enumerate}
\item there are examples of parameters $(\alpha,\beta,\nu,\rho)$ for which the recalibration of the model implied forward does not work
\item the implied volatility (since inverted from call prices) is not smooth for high strikes in some cases
\item in general, never underestimate the benefit of a pure closed form formula (i.e. Hagan 2002) over a computation involving numerical procedures ...
\end{enumerate}

}


\section{CMS Spread Coupons}

\frame{\frametitle{CMS Spread Coupons}
Still missing: a coupon class which models cms spread coupons
\begin{equation}
\tau (\textnormal{CMS10y} - \textnormal{CMS2y})
\end{equation}
possibly capped and / or floored.
}

\begin{frame}[fragile]
\frametitle{Approach 1: Formula index}
Introduce an artificial index derived from \verb+InterestRateIndex+
\vspace{2mm}
\begin{minted}[fontsize=\footnotesize, bgcolor=mintedBg]{c++}
SwapSpreadIndex(const std::string& familyName,
                const boost::shared_ptr<SwapIndex>& swapIndex1,
                const boost::shared_ptr<SwapIndex>& swapIndex2,
                const Real gearing1 = 1.0,
                const Real gearing2 = -1.0);
\end{minted}
\\
\vspace{2mm}
and build everything else on top of it as with the other coupons based
on ibor or cms indexes.
\end{frame}

\begin{frame}[fragile]
\frametitle{Approach 1: Repairing the class hiearchy}
Since the formula index does not have own fixings, we would have to
adjust the index base class by adding
\vspace{2mm}
\begin{minted}[fontsize=\footnotesize, bgcolor=mintedBg]{c++}
//! check if index allows for native fixings
virtual void checkNativeFixingsAllowed() {}
\end{minted}
\\
\vspace{2mm}
and forbid native fixings in formula based indices
\vspace{2mm}
\begin{minted}[fontsize=\footnotesize, bgcolor=mintedBg]{c++}
//! check if index allows for native fixings
virtual void checkNativeFixingsAllowed() {}
void checkNativeFixingsAllowed() {
    QL_FAIL("native fixings not allowed in swap spread index, refer to "
            "underlying indices instead");
}
\end{minted}
\\
\vspace{2mm}
A nicer solution would be to make the addFixing methods virtual and throw
an exception in CMS spread index, but they are template methods.
\end{frame}

\begin{frame}[fragile]
\frametitle{Approach 2: Construct coupons with two swap indexes}
If two swap indexes are used to construct a cms spread coupon we would need
a more flexible way to construct floating legs, since
\vspace{2mm}
\begin{minted}[fontsize=\footnotesize, bgcolor=mintedBg]{c++}
 template <typename InterestRateIndexType,
           typename FloatingCouponType,
           typename CappedFlooredCouponType>
 Leg FloatingLeg(const Schedule& schedule,
                 const std::vector<Real>& nominals,
                 const boost::shared_ptr<InterestRateIndexType>& index,
                 const DayCounter& paymentDayCounter,
                 BusinessDayConvention paymentAdj,
                 const std::vector<Natural>& fixingDays,
                 const std::vector<Real>& gearings,
                 const std::vector<Spread>& spreads,
                 const std::vector<Rate>& caps,
                 const std::vector<Rate>& floors,
                 bool isInArrears, bool isZero) {
\end{minted}
\\
\vspace{2mm}
only allows for one index. 
\end{frame}

\begin{frame}[fragile]
\frametitle{Approach 2: Coupon Factories}
We could introduce a factory instead of the template parameters
\vspace{2mm}
\begin{minted}[fontsize=\footnotesize, bgcolor=mintedBg]{c++}
Leg FloatingLeg(const FloatingCouponFactory& factory,
                const Schedule& schedule,
                ...
\end{minted}
\\
\vspace{2mm}
which can generate plain, capped / floored and digital
couons for the ibor, cms, cms spread flavours.
\vspace{2mm}
\begin{minted}[fontsize=\footnotesize, bgcolor=mintedBg]{c++}
  class FloatingCouponFactory {
    virtual boost::shared_ptr<FloatingRateCoupon>
      plainCoupon(const Date &paymentDate, Real nominal,...)
    virtual boost::shared_ptr<CappedFlooredCoupon>
      cappedFlooredCoupon(const Date &paymentDate, Real nominal,...)
    virtual boost::shared_ptr<DigitalCoupon> digitalCoupon(
      const Date &paymentDate, Real nominal, const Date &startDate,...)
    virtual Natural defaultFixingDays() const = 0;
};
\end{minted}

\end{frame}

\frame{\frametitle{CMS Spread Coupons - Summary}
\begin{itemize}
\item Introducing a formula based index would not exactly fit the semantics
of the Index class. We would have to distinguish between native
indexes (with own fixings) and derived ones. On the other hand this seems to be a quite generic approach, since formula based indexes could be used whereever an InterestRateIndex is allowed
\item Using two indexes in the spread coupon class forces us to introduce a more
flexible way to construct floating legs, e.g. via factories. This keeps the design clean and the semantics of index sharp. However this is not 100\% backward compatible since FloatingLeg is in the main QuantLib namespace.
\end{itemize}
}

\section{Credit Risk Plus}

\begin{frame}[fragile]
\frametitle{Credit Risk Plus}
A single period, nominal based credit portfolio model, based on Credit Risk Plus, with some extensions allowing for correlated sectors (Integrating Correlations, Risk, July 1999).
\vspace{2mm}
\begin{minted}[fontsize=\footnotesize, bgcolor=mintedBg]{c++}
  CreditRiskPlus(const std::vector<Real> &exposure,
     const std::vector<Real> &defaultProbability,
     const std::vector<Size> &sector,
     const std::vector<Real> &relativeDefaultVariance,
     const Matrix &correlation, const Real unit);
\end{minted}
\\
\vspace{2mm}
The loss distribution is computed analytically, so very fast. The model comes with a decomposition of the unexpected loss into single obligors' marginal losses.
\end{frame}

\section{Linear TSR CMS Coupon Pricer}

\frame{\frametitle{Linear TSR CMS Coupon Pricer}



}



\section{Gaussian1d Models}

\frame{\frametitle{Gaussian1d Models}



}




\section{ZABR, BDK, Kahale, SVI}

\frame{\frametitle{ZABR, BDK, Kahale, SVI}



}


\section{Simulated Annealing}

\frame{\frametitle{Simulated Annealing}



}


\section{Runge Kutta ODE Solver}

\frame{\frametitle{Runge Kutta ODE Solver}



}


\section{Dynamic Creator of Mersenne Twister}

\frame{\frametitle{Dynamic Creator of Mersenne Twister}



}



\section{Questions}

\begin{frame}[fragile]
\frametitle{Questions / Discussion}
\resizebox{\textwidth}{!}{
\begin{minipage}{0.75\textwidth}
\begin{figure}
	\centering
		\includegraphics{../../../Pictures/erlkoenige/french_70s_automodule05.jpg}
\end{figure}
\end{minipage}}
\\
\begin{center}
French Erlk\"onig
\end{center}
\end{frame}
\end{document}

